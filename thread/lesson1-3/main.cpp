#include<iostream>
#include<thread>
#include<memory>
#include<mutex>
//在多个线程中共享数据时，需要注意线程安全问题。如果多个线程同时访问同一个变量，并且其中至少有一个线程对该变量进行了写操作，那么就会出现数据竞争问题。
//数据竞争可能会导致程序崩溃、产生未定义的结果，或者得到错误的结果。
//为了避免数据竞争问题，需要使用同步机制来确保多个线程之间对共享数据的访问是安全的。
//常见的同步机制包括互斥量、条件变量、原子操作等。
//以下是一个简单的数据共享问题的示例代码
int shared_data=0;
std::mutex mtx;
void func()
{
   for(int i=0;i<100000;i++)
   {
      //lock本质上是先判断是否上锁了，如果上锁了就阻塞，没有就进行上锁以及后面的操作，从而保证互斥访问共享变量
      mtx.lock();
      shared_data++;
      mtx.unlock();
      //互斥量（mutex）是一种用于实现多线程同步的机制，用于确保多个线程之间对共享资源的访问互斥。
      //互斥量通常用于保护共享数据的访问，以避免多个线程同时访问同一个变量或者数据结构而导致的数据竞争问题。
      //互斥量提供了两个基本操作：lock() 和 unlock()。当一个线程调用 lock() 函数时，如果互斥量当前没有被其他线程占用，则该线程获得该互斥量的所有权，可以对共享资源进行访问。
      //如果互斥量当前已经被其他线程占用，则调用 lock() 函数的线程会被阻塞，直到该互斥量被释放为止。
      //上面的代码中，使用互斥量 mtx 来确保多个线程对 shared_data 变量的访问是安全的。
   }
}
 int main()
 {
    std:: thread t1(func);
    std:: thread t2(func);
    t1.join();
    t2.join();
    std::cout << "shared_data = " << shared_data << std::endl;    
    //上面的代码中，定义了一个名为 shared_data 的全局变量，并在两个线程中对其进行累加操作。在 main 函数中，创建了两个线程，并分别调用了 func 函数。
    //在 func 函数中，对 shared_data 变量进行了累加操作。
    //由于 shared_data 变量是全局变量，因此在两个线程中共享。对于这种共享的情况，需要使用互斥量等同步机制来确保多个线程之间对共享数据的访问是安全的。
    //如果不使用同步机制，就会出现数据竞争问题，导致得到错误的结果。
    return 0; 
 }